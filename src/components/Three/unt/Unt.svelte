<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 ./public/assets/gltf/unt.glb -t
-->

<script lang="ts">
  import type * as THREE from 'three';
  import { T, type Props, type Events, type Slots, forwardEventHandlers } from '@threlte/core';
  import { useGltf, useGltfAnimations } from '@threlte/extras';
  import { Group, LoopOnce, MeshPhongMaterial, Color } from 'three';
  import { onMount } from 'svelte';
  import { isWireFrame } from './stores.ts';

  type $$Props = Props<THREE.Group>;
  type $$Events = Events<THREE.Group>;
  type $$Slots = Slots<THREE.Group> & { fallback: {}; error: { error: any } };

  export const ref = new Group();

  type ActionName = 'TAction' | 'UAction' | 'NAction';
  type GLTFResult = {
    nodes: {
      T: THREE.Mesh;
      U: THREE.Mesh;
      N: THREE.Mesh;
    };
    materials: {
      ['Material.001']: THREE.MeshPhysicalMaterial;
    };
  };

  const gltf = useGltf<GLTFResult>(`${import.meta.env.BASE_URL}assets/gltf/unt.glb`);
  export const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref);

  if (mixer) mixer.timeScale = 1.375;
  const component = forwardEventHandlers();

  const set = () => {
    if ($actions.UAction) {
      $actions.UAction.clampWhenFinished = true;
      $actions.UAction.setLoop(LoopOnce, 0);
    }
    if ($actions.NAction) {
      $actions.NAction.clampWhenFinished = true;
      $actions.NAction.setLoop(LoopOnce, 0);
    }
    if ($actions.TAction) {
      $actions.TAction.clampWhenFinished = true;
      $actions.TAction.setLoop(LoopOnce, 0);
    }
  };
  const play = () => {
    if ($actions.UAction) {
      $actions.UAction.stop();
      $actions.UAction.play();
    }
    if ($actions.NAction) {
      $actions.NAction.stop();
      $actions.NAction.play();
    }
    if ($actions.TAction) {
      $actions.TAction.stop();
      $actions.TAction.play();
    }
  };
  $: if ($actions) {
    set();
    play();
  }

  $: material = new MeshPhongMaterial({ color: new Color('rgb(92, 138, 57)'), wireframe: $isWireFrame });
  // 再生しないと初期位置に戻ってしまう
  $: $isWireFrame,
    (() => {
      play();
    })();

  $: isClickCancelled = false;
  const canvasElement = document.querySelector('#js-canvas');
  onMount(() => {
    canvasElement?.addEventListener(
      'click',
      () => {
        if (!isClickCancelled) {
          play();
        }
      },
      false,
    );
    canvasElement?.addEventListener(
      'mousedown',
      () => {
        isClickCancelled = false;
      },
      false,
    );
    canvasElement?.addEventListener(
      'mousemove',
      () => {
        isClickCancelled = true;
      },
      false,
    );
  });
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
  {#await gltf}
    <slot name="fallback" />
  {:then gltf}
    <T.Group name="Scene">
      <T.Mesh name="U" geometry={gltf.nodes.U.geometry} {material} position={[0, 5, 0]}></T.Mesh>
      <T.Mesh name="N" geometry={gltf.nodes.N.geometry} {material} position={[0, 5, 0]}></T.Mesh>
      <T.Mesh name="T" geometry={gltf.nodes.T.geometry} {material} position={[0, 5, 0]}></T.Mesh>
    </T.Group>
  {:catch error}
    <slot name="error" {error} />
  {/await}

  <slot {ref} />
</T>
