<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 ./public/assets/gltf/unt.glb -t
-->

<script lang="ts">
  import type * as THREE from 'three';
  import { T, type Props, type Events, type Slots } from '@threlte/core';
  import { useGltf, useGltfAnimations } from '@threlte/extras';
  import { Group, LoopOnce, MeshPhongMaterial, Color } from 'three';
  import { onMount } from 'svelte';
  import { isWireFrame } from './stores.ts';

  let { ref, ...rest } = $props();

  type $$Props = Props<THREE.Group>;
  type $$Events = Events<THREE.Group>;
  type $$Slots = Slots<THREE.Group> & { fallback: {}; error: { error: any } };
  type ActionName = 'TAction' | 'UAction' | 'NAction';
  type GLTFResult = {
    nodes: {
      T: THREE.Mesh;
      U: THREE.Mesh;
      N: THREE.Mesh;
    };
    materials: {
      ['Material.001']: THREE.MeshPhysicalMaterial;
    };
  };

  ref = new Group();

  const gltf = useGltf<GLTFResult>(`${import.meta.env.BASE_URL}assets/gltf/unt.glb`);
  const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref);

  if (mixer) mixer.timeScale = 1.375;

  const set = () => {
    if ($actions.UAction) {
      $actions.UAction.clampWhenFinished = true;
      $actions.UAction.setLoop(LoopOnce, 0);
    }
    if ($actions.NAction) {
      $actions.NAction.clampWhenFinished = true;
      $actions.NAction.setLoop(LoopOnce, 0);
    }
    if ($actions.TAction) {
      $actions.TAction.clampWhenFinished = true;
      $actions.TAction.setLoop(LoopOnce, 0);
    }
  };
  const play = () => {
    if ($actions.UAction) {
      $actions.UAction.stop();
      $actions.UAction.play();
    }
    if ($actions.NAction) {
      $actions.NAction.stop();
      $actions.NAction.play();
    }
    if ($actions.TAction) {
      $actions.TAction.stop();
      $actions.TAction.play();
    }
  };

  $effect(() => {
    if ($actions) {
      set();
      play();
    }
  });
  const material = new MeshPhongMaterial({ color: new Color('rgb(92, 138, 57)'), wireframe: $isWireFrame });
  // 再生しないと初期位置に戻ってしまう
  // $: $isWireFrame,
  //   (() => {
  //     play();
  //   })();

  let isClickCancelled = $state(false);
  const canvasElement = document.querySelector('#js-canvas');
  onMount(() => {
    canvasElement?.addEventListener(
      'click',
      () => {
        if (!isClickCancelled) {
          play();
        }
      },
      false,
    );
    canvasElement?.addEventListener(
      'mousedown',
      () => {
        isClickCancelled = false;
      },
      false,
    );
    canvasElement?.addEventListener(
      'mousemove',
      () => {
        isClickCancelled = true;
      },
      false,
    );
  });
</script>

<T is={ref} dispose={false} {...rest}>
  <T.Group name="Scene">
    <T.Mesh name="U" geometry={gltf.nodes.U.geometry} {material} position={[0, 5, 0]}></T.Mesh>
    <T.Mesh name="N" geometry={gltf.nodes.N.geometry} {material} position={[0, 5, 0]}></T.Mesh>
    <T.Mesh name="T" geometry={gltf.nodes.T.geometry} {material} position={[0, 5, 0]}></T.Mesh>
  </T.Group>
</T>
